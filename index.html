<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>都道府県マップ</title>

<style>
body{
  margin:0;
  font-family:sans-serif;
  text-align:center;
  background:#f5f5f5;
}

h1{
  margin:10px 0;
  transform: scaleX(-1);
}

#map-container{
  width:100%;
  height:80vh;
  overflow:hidden;
  touch-action:none;
  position:relative;
}

svg{
  width:100%;
  height:100%;
  transform: scaleX(-1);
}

.prefecture{
  fill:white;
  stroke:#333;
  stroke-width:1;
  cursor:pointer;
}

.prefecture.active{
  fill:red;
}

button{
  margin:10px;
  padding:10px 20px;
  font-size:16px;
}
</style>
</head>

<body>

<h1>はいせんほにのかいか</h1>
<div id="map-container"></div>
<button id="resetBtn">全て解除</button>

<script>
const container = document.getElementById("map-container");

function getSVGFile(){
  return window.innerWidth <= 768
    ? "map-mobile.svg"
    : "map-full.svg";
}

let scale = 1;
let translateX = 0;
let translateY = 0;
let isPinching = false;
let isDragging = false;
let startX, startY;

function loadMap(){

  fetch(getSVGFile())
  .then(res=>res.text())
  .then(data=>{

    container.innerHTML = data;
    const svg = container.querySelector("svg");

    const g = document.createElementNS("http://www.w3.org/2000/svg","g");

    while(svg.firstChild){
      g.appendChild(svg.firstChild);
    }
    svg.appendChild(g);

    const prefs = g.querySelectorAll(".prefecture");

    prefs.forEach(pref=>{
      pref.addEventListener("click",()=>{
        if(isPinching || isDragging) return;
        pref.classList.toggle("active");
      });
    });

    updateTransform(g);

    // ===== ピンチズーム =====
    let lastDistance = 0;

    container.addEventListener("touchstart", e=>{
      if(e.touches.length===2){
        isPinching = true;
        lastDistance = getDistance(e.touches);
      }
      else if(e.touches.length===1){
        isDragging = true;
        startX = e.touches[0].clientX - translateX;
        startY = e.touches[0].clientY - translateY;
      }
    });

    container.addEventListener("touchmove", e=>{

      if(e.touches.length===2){
        e.preventDefault();

        const distance = getDistance(e.touches);
        const diff = distance - lastDistance;

        let newScale = scale + diff * 0.005;
        newScale = Math.max(1, Math.min(newScale,5));

        const rect = container.getBoundingClientRect();
        const centerX = (e.touches[0].clientX + e.touches[1].clientX)/2 - rect.left;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY)/2 - rect.top;

        translateX -= (centerX - translateX) * (newScale/scale - 1);
        translateY -= (centerY - translateY) * (newScale/scale - 1);

        scale = newScale;

        updateTransform(g);

        lastDistance = distance;
      }

      else if(e.touches.length===1 && isDragging && scale>1){
        translateX = e.touches[0].clientX - startX;
        translateY = e.touches[0].clientY - startY;
        updateTransform(g);
      }

    });

    container.addEventListener("touchend", e=>{
      if(e.touches.length<2){
        setTimeout(()=>{isPinching=false},100);
      }
      if(e.touches.length===0){
        isDragging=false;
      }
    });

    // ===== マウスドラッグ（PC）=====
    container.addEventListener("mousedown", e=>{
      if(scale<=1) return;
      isDragging = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
    });

    container.addEventListener("mousemove", e=>{
      if(!isDragging) return;
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      updateTransform(g);
    });

    container.addEventListener("mouseup", ()=>{
      isDragging=false;
    });

    container.addEventListener("mouseleave", ()=>{
      isDragging=false;
    });

    function updateTransform(g){
      g.setAttribute(
        "transform",
        `translate(${translateX},${translateY}) scale(${scale})`
      );
    }

    function getDistance(touches){
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx+dy*dy);
    }

  });
}

loadMap();

window.addEventListener("resize",()=>{
  container.innerHTML="";
  scale=1;
  translateX=0;
  translateY=0;
  loadMap();
});

document.getElementById("resetBtn").addEventListener("click",()=>{
  document.querySelectorAll(".prefecture").forEach(p=>{
    p.classList.remove("active");
  });
});
</script>

</body>
</html>

